<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2019%2F09%2F11%2Fsoftware%2F</url>
    <content type="text"><![CDATA[定义 线性表是具有相同类型的n（n>=0）个元素的有限序列，其中n 为表长。当n=0时，该表为空表。 线性表是逻辑结构,表示元素之间相邻的关系，顺序表及链表为存储结构。 若L命名为线性表，则一般表示L=（a1,a2,.....ai,ai+1,...,an) 线性表的九种基本操作1.InitList(&amp;L):初始化表，构造一个空的线性表 2.DestoryList(&amp;L):销毁操作，销毁线性表，并释放线性表所占用的内存空间3.LocateElem(L,e):按值查找，在表L中查找给定关键字值e的元素，返回查找到的第一个元素4.GetElem(L,i):按位查找，获取表第i个位置的元素5.ListInsert(&amp;L,i,e):插入操作，在线性表L中的第i个位置上插入指定元素e(规定前插）6.ListDelete(&amp;L,i,&amp;e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。7.PrintList(L):输出操作，按前后顺序输出线性表的各个元素8.Empty(L):判空操作，若L为空表则返回TRUE否则返回FALSE9.Length(L):求表长返回线性表L的长度，即L中数据元素的个数。 顺序表 线性表的顺序存储又称顺序表 一组地址连续存放的存储单元依次存放线性表的各个元素，从而使逻辑上相邻的元素在物理位置上也保持相邻（逻辑顺序与物理顺序相同） 通常用数组来实现顺序表，它们之间存在很多不同点 1.数组的下标从0开始，线性表的下标从1开始。 2.数组的容量不可扩充，顺序表的容量可增加 3.数组可以是多维的，线性表只能是一维的 顺序表可实现随机存取（Loc(A)+sizeof(ElemType),Loc(A)+2*sizeof(ElemType)...) 123456//数组静态分配#define Maxsize 50typedef struct&#123; ElemType data[Maxsize];//存放顺序表中元素的数组 int length;//顺序表的长度&#125;sqlist; 1234567#define Maxsize 50typedef struct&#123; ElemType *data;//指针表示顺序表的首地址，即第一个数据元素的地址 int length;//顺序表的长度 &#125;sqlist; //动态分配语句 //L.data=(ElemType*)malloc(sizeof(ElemType)*Initsize) 顺序表的基本操作123456789101112131415//定义顺序表及其初始化操作#define MaxSize 100typedef struct&#123; ElemType *data; int length; &#125;sqlistStatus InitList(sqlist &amp;L)&#123;L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize) ;if (L.data==NULL)exit(OVERFLOW); //存储分配失败L.length=0; //空表的长度为0L.listsize=InitSize; //初始存储容量return OK; &#125; 1234567891011//顺序表的插入操作ListInsert(sqlist &amp;L,int i,ElemType e)&#123; //判断插入位置的合法性 if(i&lt;1||i&gt;=L.length+1) return ERROR;//顺序表的数据元素是连续的 if(L.length&gt;=Maxsize) return ERROR; for (int j=L.length;j&gt;=i;j-- ) L.data[j]=L.data[j-1]; L.data[i-1]=e; L.length++;//线性表的长度加一 return ok;&#125; 12345678910/顺序表的删除操作ListDelete(sqlist &amp;L,int i,ElemType &amp;e)&#123; //判断删除位置的合法性 if(i&lt;1||i&gt;L.length) return ERROR; e=L.data[i-1]//将删除的元素存放在引用变量e中 for(int j=i;j&lt;L.length;j++) L.data[j-1]=L.data[j]; L.length--;//线性表的长度减一，清空了原顺序表的最后一个元素 return OK; &#125; 12345678//顺序表的按值查找操作int LocateElem(sqlist L,ElemType e)&#123; int i; for (i=0;i&lt;L.length;i++) if(L.data[i]==e) return i+1; else return 0;//查找失败 &#125; 单链表 线性表的链式存储又称为单链表 通过一组任意的存储单元来存储线性表中的数据元素 通过指针来实现线性逻辑关系 单链表不可以随机存取，只可以进行顺序存取 结点：数据域+指针域 头指针与头节点的区别 1.无论是否引入头节点，头指针所指向的一定是链表的第一个节点 2. 头节点是带头节点链表的第一个节点，其数据域内通常不存储数据 引入头节点的原因 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了 1234 typedef struct LNode&#123; ElemType data; struct LNode *next;&#125;LNode,*LinkList; 123456789101112131415//头插法建立单链表 LinkList List_HeadInsert(LinkList &amp;L)&#123; LNode *s;int x; L=(LinkList)malloc(sizeof(LNode)); L-&gt;NULL; scanf(&quot;%d&quot;,&amp;x); while(x!=9999)&#123; s=(LNode*)malloc(sizeof(LNode)) ; s-&gt;data=x; s-&gt;next=L-&gt;next; L-&gt;next=s; scanf(%d,&amp;x); &#125; return L; &#125;]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start 123Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy hello os algorithm computer architecture ！[tip](/images/test.png) More info: [Deployment](https://hexo.io/docs/deployment.html)]]></content>
  </entry>
</search>
