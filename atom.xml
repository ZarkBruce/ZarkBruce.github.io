<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Research Space</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ZarkBruce.github.io/"/>
  <updated>2019-10-12T12:51:42.129Z</updated>
  <id>https://ZarkBruce.github.io/</id>
  
  <author>
    <name>michaelbobo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interrupt</title>
    <link href="https://ZarkBruce.github.io/2019/10/12/interrupt/"/>
    <id>https://ZarkBruce.github.io/2019/10/12/interrupt/</id>
    <published>2019-10-12T08:59:05.000Z</published>
    <updated>2019-10-12T12:51:42.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断（Interrupt"><a href="#中断（Interrupt" class="headerlink" title="中断（Interrupt)"></a>中断（Interrupt)</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>　　我们可以考虑一个经典的执行I/O的程序，首先设备驱动(device driver)在设备控制器（device controller）里载入合适的寄存器（registers），设备控制器读取寄存器的内容来判断做何种操作。接着设备中的数据开始传输至它的局部缓冲区（local buffer),数据传输过程完成后，设备控制器开始将控制交付给操作系统的其他部分，除此之外，设备控制器还将返回状态信息（status infoamtion)给设备驱动器（例如读操作已完成），那么设备控制器是如何提醒设备驱动该操作是否完成的呢？这就是通过中断来完成的。</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>　　硬件可以在任何时间向CPU发送信号触发一次中断，通常是通过系统总线（在一个计算机系统中有很多的总线，系统总线是大部分组件之间的主要传输路径）。软件可以通过system call(also  called monitor call)触发中断。当CPU被中断时，它会停下当前工作并转移操作至一个固定的位置，这个位置通常包含了中断服务程序（interrupt service routine）的起始地址(starting address),之后中断服务程序开始执行，完成执行操作后，CPU重新开始被中断的计算操作。<br><br>下图是一个执行输出程序的中断时间轴。过程描述：1.开始时用户程序(user program)处于运行态,I/O设备处于空闲态（idle）2.I/O request发出后经过一小段时间I/O设备开始传输—&gt;传输完成 ，I/O设备恢复空闲态。3.中断信号发出，同时I/O interrupt processing开始运行直至中断处理完成，用户程序恢复执行被中断的操作。<br><img src="interrupt/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6.png" alt="单个执行输出程序的中断操作时间轴"><br><br>　　中断在计算机系统里会频繁的出现，因此中断被触发后应在很短的时间内得到处理。一个包含若干个指向中断程序的指针表格可以提升中断被处理的速度。中断程序通过指针表格间接访问，而不通过其它中间程序来访问。通常来说，指针表格存储在低内存（low memory)位置（前100或者临近前100的位置），这种程序存储着各种设备中断服务程序的地址。这个地址的数组或者中断向量（interrupt vector)可通过唯一设备号来索引，以给设备提供中断服务程序的地址。Windows或者UNIX操作系统就是采用这种方式来处理中断的。<br><br>　　中断体系必须保存一切被中断的状态信息，在中断处理完毕之后必须恢复之前的状态。如果中断程序需要修改处理器状态，例如，修改寄存器的值，那么就必须要清晰地保存当前状态，并且在返回之前恢复该状态。在中断处理完毕之后，保存的返回地址被重新载入程序计数器，被中断的计算恢复，中断就好像没有发生过一样。<br></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>　　CPU中有一种在执行每条指令后进行感知的中断请求线（interrupt-request　line），当CPU检测到控制器通过中断请求线上发出了一个信号，它会读取一个中断号（interrupt　number),以该中断号为索引值访问中断矢量（interrupt　vector）并跳转至中断处理程序（interrupt-handler routine）【 a set of memory locations (interrupt vectors) associated with each interrupt request line that holds the start address of the interrupt handling routine.】，然后CPU在索引值绑定的地址开始运行，中断处理器会存储操作中任何将要改变的状态，并决定中断的目标，执行必要的处理，执行状态恢复（state　restore),在中断发生前运行return_from_interrupt指令返回cpu运行状态（execution state）。</p><blockquote><p> The device controller raises an interrupt by asserting a signal on theinterrupt request line, the CPU catches the interrupt and dispatches it to theinterrupt handler, and the handler clears the interrupt by servicing the device.</p></blockquote>![hardware of computer system](interrupt/中断.png)　<br>    在现代操作系统中，我们需要更为复杂的中断处理特性：1.在临界处理（critical processing）中推迟中断的能力。2.更高效的方式为设备派遣中断处理器3.多级中断，使操作系统可以辨别高、低优先级中断。　　在现代操作系统中，这三个中断处理特性由cpu和中断控制器硬件（interrupt-controller hardware)提供，如Programmble Interrupt Controller(PIC).PIC作为辅助中断硬件，它可以是外部的或者集成在芯片本身。PIC包含若干个中断请求线和一个输出中断线。中断请求线用来处理来自外部的中断，输出中断线则用来请求来自CPU的中断。<br>## 中断优先级　　硬件通过中断优先级（Interrupt Priority Level）来联系各个中断请求线。当前的处理器优先级存储在CPU寄存器中。如果当前处理器的优先级大于或等于中断的优先级，则忽略该中断。如果不是，处理器的优先级转变为和中短线的优先级相同，并将控制权转移给相应的中断处理器。当中断处理器完成操作时，处理器的优先级降低，被中断的活动重新开始执行。注意：中断处理进程可以被更高优先级的中断处理进程中断。因为中断服务程序和其它中断服务程序之间会相互干扰，所以最合适的方法来管理中断就是使所有中断更加透明。## 软件引起中断软件引起的中断可分为两类：1.处理器本身的异常情况2.特殊指令执行时引发的中断<p>  前者被称为异常（exception），用于错误（error）或者在线程执行时出现异常且不可在线程内处理的事件。例如，如果处理器的算术逻辑单元被命令取做一个数被0除的操作，就会产生divide-by-zero-exception，使计算机放弃这个计算并且显示一个错误信息。软件中断指令可以用来实现各种目的的系统访问（system call），例如设备驱动这一类低级系统软件。操作系统经常在和硬盘驱动交流来请求将要读或者将要写入硬盘的数据时使用软件中断（实现系统访问）。</p>　　操作系统中一种典型的中断利用就是编程一个计数器实现周期性中断。<br><blockquote>    <p> These periodic interrupts are normally handled by the context switching routine of the task scheduler to schedule threads according to their priorities. Another example of I/O interrupt is found when a disk interrupt signals the completion of a data transfer from or to the disk peripheral and a thread waiting to read or write a file starts up again.</p></blockquote>## 中断的分类中断可以分为以下几类：<ul><li>Maskable interrupt (MI): a hardware interrupt that may be ignored by setting a bit in an interrupt mask register’s (IMR) bit-mask. A hardware interrupt that lacks an associated bit-mask is a non-maskable interrupt (NMI). An NMI interrupt can never be ignored. NMIs are used for the highest priority tasks such as timers,especially watchdog timers. MIs or NMIs can be used by I/O device controllers to signal operations such as write, read, status, error or other I/O operations.</li><li>Inter-processor interrupt (IPI): a special case of interrupt that is generated by one processor to interrupt another processor in a multiprocessor system.</li><li>Hardware interrupt: generated by some device such as the timer (periodically),by I/O device drivers (in response to some event) or by the DMA.</li><li>Software interrupt: generated by some condition that occurs as a result of an instruction execution, such as arithmetic overflow, division by zero or an attempt to execute an illegal instruction. Software interrupts are also used to implement system calls.</li><li>Spurious interrupt: a hardware interrupt that is unwanted. They are typically gen-erated by system conditions such as electrical interference on an interrupt line,power failure or through incorrectly designed hardware. Also they are generated by errors in the memory (e.g., memory parity error) or the devices.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中断（Interrupt&quot;&gt;&lt;a href=&quot;#中断（Interrupt&quot; class=&quot;headerlink&quot; title=&quot;中断（Interrupt)&quot;&gt;&lt;/a&gt;中断（Interrupt)&lt;/h1&gt;&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; c
      
    
    </summary>
    
      <category term="Operating System" scheme="https://ZarkBruce.github.io/categories/Operating-System/"/>
    
    
      <category term="OSC" scheme="https://ZarkBruce.github.io/tags/OSC/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://ZarkBruce.github.io/2019/09/11/linear_list/"/>
    <id>https://ZarkBruce.github.io/2019/09/11/linear_list/</id>
    <published>2019-09-11T15:35:06.000Z</published>
    <updated>2019-09-20T14:06:39.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li> 线性表是具有相同类型的n（n>=0）个元素的有限序列，其中n 为表长。当n=0时，该表为空表。 </li><li> 线性表是逻辑结构,表示元素之间相邻的关系，顺序表及链表为存储结构。</li><li>若L命名为线性表，则一般表示L=（a1,a2,.....ai,ai+1,...,an)</li></ul><h2 id="线性表的九种基本操作"><a href="#线性表的九种基本操作" class="headerlink" title="线性表的九种基本操作"></a>线性表的九种基本操作</h2><p>1.InitList(&amp;L):初始化表，构造一个空的线性表 <br><br>2.DestoryList(&amp;L):销毁操作，销毁线性表，并释放线性表所占用的内存空间<br><br>3.LocateElem(L,e):按值查找，在表L中查找给定关键字值e的元素，返回查找到的第一个元素<br><br>4.GetElem(L,i):按位查找，获取表第i个位置的元素<br><br>5.ListInsert(&amp;L,i,e):插入操作，在线性表L中的第i个位置上插入指定元素e(规定前插）<br><br>6.ListDelete(&amp;L,i,&amp;e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。<br><br>7.PrintList(L):输出操作，按前后顺序输出线性表的各个元素<br><br>8.Empty(L):判空操作，若L为空表则返回TRUE否则返回FALSE<br><br>9.Length(L):求表长返回线性表L的长度，即L中数据元素的个数。<br></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><ul><li>线性表的顺序存储又称顺序表</li><li>一组地址连续存放的存储单元依次存放线性表的各个元素，从而使逻辑上相邻的元素在物理位置上也保持相邻（逻辑顺序与物理顺序相同）</li><li>通常用数组来实现顺序表，它们之间存在很多不同点</li>1.数组的下标从0开始，线性表的下标从1开始。<br>2.数组的容量不可扩充，顺序表的容量可增加<br>3.数组可以是多维的，线性表只能是一维的<br><li>顺序表可实现随机存取（Loc(A)+sizeof(ElemType),Loc(A)+2*sizeof(ElemType)...)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//数组静态分配</span><br><span class="line">#define Maxsize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[Maxsize];//存放顺序表中元素的数组</span><br><span class="line">    int length;//顺序表的长度</span><br><span class="line">&#125;sqlist;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define Maxsize 50</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *data;//指针表示顺序表的首地址，即第一个数据元素的地址</span><br><span class="line">    int length;//顺序表的长度</span><br><span class="line">    &#125;sqlist;</span><br><span class="line">    //动态分配语句</span><br><span class="line">    //L.data=(ElemType*)malloc(sizeof(ElemType)*Initsize)</span><br></pre></td></tr></table></figure><h2 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义顺序表及其初始化操作</span><br><span class="line">#define MaxSize 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *data;</span><br><span class="line">    int length;   </span><br><span class="line">&#125;sqlist</span><br><span class="line"></span><br><span class="line">Status InitList(sqlist &amp;L)&#123;</span><br><span class="line">L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize) ;</span><br><span class="line">if (L.data==NULL)</span><br><span class="line">exit(OVERFLOW); //存储分配失败</span><br><span class="line">L.length=0;   //空表的长度为0</span><br><span class="line">L.listsize=InitSize; //初始存储容量</span><br><span class="line">return OK;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//顺序表的插入操作</span><br><span class="line">ListInsert(sqlist &amp;L,int i,ElemType e)&#123;</span><br><span class="line">    //判断插入位置的合法性</span><br><span class="line">    if(i&lt;1||i&gt;=L.length+1) return ERROR;//顺序表的数据元素是连续的</span><br><span class="line">    if(L.length&gt;=Maxsize) return ERROR;</span><br><span class="line">    for (int j=L.length;j&gt;=i;j-- )</span><br><span class="line">    L.data[j]=L.data[j-1];</span><br><span class="line">    L.data[i-1]=e;</span><br><span class="line">    L.length++;//线性表的长度加一</span><br><span class="line">    return ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/顺序表的删除操作</span><br><span class="line">ListDelete(sqlist &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">    //判断删除位置的合法性</span><br><span class="line">  if(i&lt;1||i&gt;L.length) return ERROR;</span><br><span class="line">  e=L.data[i-1]//将删除的元素存放在引用变量e中</span><br><span class="line">  for(int j=i;j&lt;L.length;j++)</span><br><span class="line">  L.data[j-1]=L.data[j];</span><br><span class="line">  L.length--;//线性表的长度减一，清空了原顺序表的最后一个元素</span><br><span class="line">  return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//顺序表的按值查找操作</span><br><span class="line">int LocateElem(sqlist L,ElemType e)&#123;</span><br><span class="line">  int i;</span><br><span class="line">  for (i=0;i&lt;L.length;i++)</span><br><span class="line">  if(L.data[i]==e)</span><br><span class="line">  return i+1;</span><br><span class="line"> else return 0;//查找失败  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ul><li>线性表的链式存储又称为单链表</li><li>通过一组任意的存储单元来存储线性表中的数据元素</li><li>通过指针来实现线性逻辑关系</li><li>单链表不可以随机存取，只可以进行顺序存取</li><li>结点：数据域+指针域</li><li>头指针与头节点的区别</li>1.无论是否引入头节点，头指针所指向的一定是链表的第一个节点 <br>2. 头节点是带头节点链表的第一个节点，其数据域内通常不存储数据<br><li>引入头节点的原因</li>1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了<br>2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了<br></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  typedef struct LNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//头插法建立单链表</span><br><span class="line">   LinkList List_HeadInsert(LinkList &amp;L)&#123;</span><br><span class="line">       LNode *s;int x;</span><br><span class="line">      L=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">      L-&gt;NULL;</span><br><span class="line">      scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">      while(x!=9999)&#123;</span><br><span class="line">        s=(LNode*)malloc(sizeof(LNode)) ;</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        scanf(%d,&amp;x);</span><br><span class="line">      &#125;</span><br><span class="line">      return  L;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt; 线性表是具有相同类型的n（n&gt;=0）个元素的有限序列，其中n 为表长。当n=0时，该表为空表。 &lt;/li&gt;
&lt;li&gt; 线性表是
      
    
    </summary>
    
      <category term="Data Structure" scheme="https://ZarkBruce.github.io/categories/Data-Structure/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ZarkBruce.github.io/2019/08/04/hello-world/"/>
    <id>https://ZarkBruce.github.io/2019/08/04/hello-world/</id>
    <published>2019-08-04T07:23:01.228Z</published>
    <updated>2019-09-11T15:50:11.609Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start-123"><a href="#Quick-Start-123" class="headerlink" title="Quick Start 123"></a>Quick Start 123</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p><font color="#DC143C">hello</font><br></p><ul><li><a href><font color="#DC143C">os</font></a></li><li>algorithm</li><li>computer architecture</li></ul>！[tip](/images/test.png)More info: [Deployment](https://hexo.io/docs/deployment.html)]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
